<!-- === Brand Comparison Heatmap ===
D3.js heatmap showing concept coverage by brand
Rows: Top 20 concepts, Columns: 5 brands (Samsung, LG, TCL, Sony, Hisense)
Color intensity: Mention count
-->

<!-- Heatmap Section HTML -->
<div class="container">
    <div class="chart-card full-width">
        <div class="chart-header">
            <div class="chart-title">
                Brand Comparison Heatmap
                <div class="tooltip-icon">
                    <span>?</span>
                    <div class="tooltip-text">Concept coverage across brands. Color intensity shows mention volume - darker means more mentions.</div>
                </div>
            </div>
            <button class="download-btn" title="Download">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            </button>
        </div>
        <div class="heatmap-container" id="brand-heatmap"></div>
        <div class="heatmap-legend" id="heatmap-legend">
            <span class="legend-label">Less mentions</span>
            <div class="legend-gradient"></div>
            <span class="legend-label">More mentions</span>
        </div>
    </div>
</div>

<!-- Heatmap CSS -->
<style>
.heatmap-container {
    width: 100%;
    overflow-x: auto;
    padding: var(--spacing-md) 0;
}

.heatmap-container svg {
    display: block;
    margin: 0 auto;
}

.heatmap-cell {
    stroke: #fff;
    stroke-width: 1px;
    cursor: pointer;
    transition: opacity 0.2s;
}

.heatmap-cell:hover {
    stroke: var(--color-primary);
    stroke-width: 2px;
}

.heatmap-label {
    font-family: var(--font-body);
    font-size: 12px;
    fill: var(--color-text-secondary);
}

.heatmap-label.row-label {
    text-anchor: end;
}

.heatmap-label.col-label {
    text-anchor: middle;
    font-weight: 600;
}

.heatmap-legend {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-md);
    padding: var(--spacing-md) 0;
    margin-top: var(--spacing-md);
    border-top: 1px solid var(--color-border);
}

.heatmap-legend .legend-label {
    font-family: var(--font-body);
    font-size: 12px;
    color: var(--color-text-secondary);
}

.heatmap-legend .legend-gradient {
    width: 150px;
    height: 12px;
    background: linear-gradient(to right, #e3e8f4, #1428A0);
    border-radius: var(--radius-sm);
}

/* Heatmap tooltip */
.heatmap-tooltip {
    position: fixed;
    background: #333;
    color: white;
    padding: 8px 12px;
    border-radius: var(--radius-md);
    font-size: 12px;
    font-family: var(--font-body);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 1000;
    max-width: 200px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.heatmap-tooltip.visible {
    opacity: 1;
}

.heatmap-tooltip .tooltip-brand {
    font-weight: 600;
    color: var(--color-accent-cyan);
}

.heatmap-tooltip .tooltip-concept {
    font-weight: 600;
    margin-bottom: 4px;
}

.heatmap-tooltip .tooltip-value {
    font-size: 14px;
    font-weight: 700;
}
</style>

<!-- Heatmap Tooltip Element -->
<div class="heatmap-tooltip" id="heatmap-tooltip"></div>

<!-- Heatmap JavaScript -->
<script>
(function() {
    // Configuration
    const config = {
        width: 900,
        height: 600,
        margin: { top: 80, right: 30, bottom: 30, left: 180 },
        cellPadding: 2,
        brands: ['Samsung', 'LG', 'Sony', 'TCL', 'Hisense'],
        maxConcepts: 20
    };

    const colorScale = d3.scaleSequential()
        .interpolator(d3.interpolateBlues)
        .domain([0, 1]); // Will be updated with actual max

    // Brand colors for column headers
    const brandColors = SupabaseData.colors.brand;

    // Sample data structure (will be replaced with live data)
    const sampleData = {
        concepts: [
            'OLED Technology', 'QLED Display', 'Gaming TVs', 'Mini-LED',
            '4K Resolution', 'Smart Features', 'HDR Support', 'Refresh Rate',
            'Sound Quality', 'Picture Quality', 'Brightness', 'Anti-Glare',
            'Motion Handling', 'Input Lag', 'Size Options', 'Price Value',
            'Design', 'Connectivity', 'Voice Control', 'Energy Efficiency'
        ],
        matrix: [] // Will be populated
    };

    // Generate sample matrix data
    sampleData.matrix = sampleData.concepts.map(concept => ({
        concept,
        values: config.brands.map(brand => ({
            brand,
            value: Math.floor(Math.random() * 500) + (brand === 'Samsung' ? 200 : 0)
        }))
    }));

    const tooltip = d3.select('#heatmap-tooltip');

    function renderHeatmap(data) {
        const container = d3.select('#brand-heatmap');
        container.selectAll('*').remove();

        const innerWidth = config.width - config.margin.left - config.margin.right;
        const innerHeight = config.height - config.margin.top - config.margin.bottom;

        const cellWidth = innerWidth / config.brands.length - config.cellPadding;
        const cellHeight = innerHeight / data.concepts.length - config.cellPadding;

        // Find max value for color scaling
        const maxValue = d3.max(data.matrix.flatMap(row => row.values.map(v => v.value)));
        colorScale.domain([0, maxValue]);

        const svg = container.append('svg')
            .attr('width', config.width)
            .attr('height', config.height);

        const g = svg.append('g')
            .attr('transform', `translate(${config.margin.left},${config.margin.top})`);

        // Column headers (brands)
        g.selectAll('.col-label')
            .data(config.brands)
            .join('text')
            .attr('class', 'heatmap-label col-label')
            .attr('x', (d, i) => i * (cellWidth + config.cellPadding) + cellWidth / 2)
            .attr('y', -20)
            .attr('fill', d => SupabaseData.colors.getBrandColor(d))
            .text(d => d);

        // Row groups
        const rows = g.selectAll('.heatmap-row')
            .data(data.matrix)
            .join('g')
            .attr('class', 'heatmap-row')
            .attr('transform', (d, i) => `translate(0, ${i * (cellHeight + config.cellPadding)})`);

        // Row labels (concepts)
        rows.append('text')
            .attr('class', 'heatmap-label row-label')
            .attr('x', -10)
            .attr('y', cellHeight / 2)
            .attr('dy', '0.35em')
            .text(d => {
                const name = d.concept;
                return name.length > 22 ? name.substring(0, 20) + '...' : name;
            })
            .append('title')
            .text(d => d.concept);

        // Cells
        rows.selectAll('.heatmap-cell')
            .data(d => d.values.map(v => ({ ...v, concept: d.concept })))
            .join('rect')
            .attr('class', 'heatmap-cell')
            .attr('x', (d, i) => i * (cellWidth + config.cellPadding))
            .attr('y', 0)
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('rx', 3)
            .attr('fill', d => colorScale(d.value))
            .on('mouseenter', function(event, d) {
                tooltip
                    .html(`
                        <div class="tooltip-concept">${d.concept}</div>
                        <div><span class="tooltip-brand">${d.brand}</span></div>
                        <div class="tooltip-value">${d.value.toLocaleString()} mentions</div>
                    `)
                    .classed('visible', true)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');

                // Highlight row and column
                rows.selectAll('.heatmap-cell')
                    .style('opacity', cell => cell.brand === d.brand || cell.concept === d.concept ? 1 : 0.3);
            })
            .on('mousemove', function(event) {
                tooltip
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseleave', function() {
                tooltip.classed('visible', false);
                rows.selectAll('.heatmap-cell').style('opacity', 1);
            })
            .on('click', function(event, d) {
                // Dispatch event for filtering
                document.dispatchEvent(new CustomEvent('heatmapCellClick', {
                    detail: { concept: d.concept, brand: d.brand }
                }));
            });

        // Add value text to cells with enough space
        if (cellWidth > 40 && cellHeight > 20) {
            rows.selectAll('.cell-value')
                .data(d => d.values.map(v => ({ ...v, concept: d.concept })))
                .join('text')
                .attr('class', 'cell-value')
                .attr('x', (d, i) => i * (cellWidth + config.cellPadding) + cellWidth / 2)
                .attr('y', cellHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'middle')
                .attr('fill', d => d.value > maxValue * 0.6 ? '#fff' : '#333')
                .attr('font-size', '10px')
                .attr('font-family', 'var(--font-body)')
                .attr('pointer-events', 'none')
                .text(d => d.value > 0 ? d.value : '');
        }
    }

    // Load data from Supabase
    async function loadHeatmapData() {
        try {
            if (typeof SupabaseData === 'undefined') {
                console.warn('SupabaseData not available, using sample data');
                renderHeatmap(sampleData);
                return;
            }

            const mentionsData = await SupabaseData.fetchConceptMentions({ limit: 1000 });

            if (mentionsData.length > 0) {
                const heatmapData = SupabaseData.transform.heatmap(mentionsData, config.maxConcepts);
                renderHeatmap({
                    concepts: heatmapData.concepts,
                    matrix: heatmapData.matrix
                });
            } else {
                renderHeatmap(sampleData);
            }
        } catch (error) {
            console.error('Error loading heatmap data:', error);
            renderHeatmap(sampleData);
        }
    }

    // Listen for filter changes
    document.addEventListener('filtersChanged', loadHeatmapData);

    // Initial render
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadHeatmapData);
    } else {
        loadHeatmapData();
    }
})();
</script>
